// ABCtrees.slim  (tree-seq + deleterious-forward-only version)
//
// Required -d parameters:
//   ID, gmu, imu, gd, id, gdfe, idfe
//
// Optional -d parameters:
//   END (default 40000)
//   OUTTREES (default ".")
//   SIMPLIFY_INTERVAL (default 200)
//   NPOP (default computed from Ne_real/Q)
//   SELF (default 0.98)
//	  Q (defaultd 50)
//   GENOMEINFO_DIR (default "genomeinfo")  // directory containing gene100.csv + intergene100.csv
//   GENEFILE (overrides GENOMEINFO_DIR)
//   INTERFILE (overrides GENOMEINFO_DIR)

initialize() {

    // ----------------------------
    // Defaults for optional params
    // ----------------------------
    if (!exists("Q")) defineConstant("Q", 50.0);
    if (!exists("NE_REAL"))defineConstant("NE_REAL", 300000.0);
    if (!exists("R_REAL")) defineConstant("R_REAL", 4e-8);

    if (!exists("END")) defineConstant("END", 40000);
    if (!exists("OUTTREES")) defineConstant("OUTTREES", ".");
    if (!exists("SIMPLIFY_INTERVAL")) defineConstant("SIMPLIFY_INTERVAL", 200);
    if (!exists("SELF")) defineConstant("SELF", 0.98);

    // If NPOP not provided, compute from Ne_real / Q
    if (!exists("NPOP")) defineConstant("NPOP", asInteger(round(NE_REAL / Q)));
    
    // Portable genomeinfo paths:
    // By default, look for ./genomeinfo/gene100.csv and ./genomeinfo/intergene100.csv
    if (!exists("GENOMEINFO_DIR")) defineConstant("GENOMEINFO_DIR", "genomeinfo");

    if (!exists("GENEFILE"))
        defineConstant("GENEFILE", paste(GENOMEINFO_DIR, "/gene100.csv", sep=""));
    if (!exists("INTERFILE"))
        defineConstant("INTERFILE", paste(GENOMEINFO_DIR, "/intergene100.csv", sep=""));

    // ----------------------------
    // Read genomic intervals
    // ----------------------------
    genes = readFile(GENEFILE);
    gene_starts = NULL;
    gene_stops  = NULL;

    for (line in genes) {
        components = strsplit(line, ",");
        if (size(components) < 2) next;

        start = asInteger(components[0]);
        stop  = asInteger(components[1]);

        // Skip header/malformed lines
        if (isNULL(start) | isNULL(stop)) next;

        gene_starts = c(gene_starts, start);
        gene_stops  = c(gene_stops,  stop);
    }

    intergenes = readFile(INTERFILE);
    inter_starts = NULL;
    inter_stops  = NULL;

    for (line in intergenes) {
        components = strsplit(line, ",");
        if (size(components) < 2) next;

        start = asInteger(components[0]);
        stop  = asInteger(components[1]);

        if (isNULL(start) | isNULL(stop)) next;

        inter_starts = c(inter_starts, start);
        inter_stops  = c(inter_stops,  stop);
    }

    defineConstant("L", max(gene_stops) + 1);

    // ----------------------------
    // Nucleotide-based model (must come before initializeTreeSeq)
    // ----------------------------
    initializeSLiMOptions(nucleotideBased=T);

    // Tree-sequence recording
    initializeTreeSeq();

    // Ancestral nucleotides
    initializeAncestralNucleotides(randomNucleotides(L));

// ----------------------------
    // Mutation types (deleterious-only forward)
    //
    // IMPORTANT: we treat gdfe/idfe as BIOLOGICAL means (negative).
    // We scale selection coefficients by Q to preserve Ne*s.
    // Shape is fixed at 0.270 (your choice / literature-aligned).
    // ----------------------------

 // Scale mean selection coefficients for simulation
    gdfe_sim = gdfe * Q;
    idfe_sim = idfe * Q;

    // ----------------------------
    // Mutation types (deleterious-only forward)
    // ----------------------------
    initializeMutationTypeNuc("m2", 0.1, "g", gdfe_sim, 0.270);  // gene deleterious
    initializeMutationTypeNuc("m3", 0.1, "g", idfe_sim, 0.270);  // intergene deleterious

    // Clamp gd/id into [0,1] for safety (fractions not scaled)
    gd_eff = max(0.0, min(1.0, gd));
    id_eff = max(0.0, min(1.0, id));

    // Scale mutation rates for simulation
    // gmu/imu are BIOLOGICAL totals; only deleterious component is simulated forward
    gmu_del_sim = (gmu * gd_eff) * Q;
    imu_del_sim = (imu * id_eff) * Q;
       
    initializeGenomicElementType("g1", m2,1.0, mmJukesCantor(gmu_del_sim));
    initializeGenomicElementType("g2", m3,1.0, mmJukesCantor(imu_del_sim));

    initializeGenomicElement(g1, gene_starts, gene_stops);
    initializeGenomicElement(g2, inter_starts, inter_stops);

	 //scale recombination rate for simulation
    initializeRecombinationRate(R_REAL * Q);
}

// ----------------------------
// Truncation guardrail: prevent impossible s < -1
// (Does NOT change the prior on gdfe/idfe; only trims extreme tail draws.)
// ----------------------------
mutation(m2) {
    if (mut.selectionCoeff < -1.0)
        mut.setSelectionCoeff(-1.0);
    return T;
}

mutation(m3) {
    if (mut.selectionCoeff < -1.0)
        mut.setSelectionCoeff(-1.0);
    return T;
}

1 late() {
    sim.addSubpop("p1", NPOP);
    p1.setSelfingRate(SELF);
}

// Periodic simplify + end condition (END is configurable)
1:40000 late() {

    gen = community.tick;

    // Periodic tree-seq simplification
    if (SIMPLIFY_INTERVAL > 0) {
        if (gen % SIMPLIFY_INTERVAL == 0)
            sim.treeSeqSimplify();
    }

    // Stop and output at END
    if (gen == END) {
        catn("Simulation reached generation " + END + " for ID " + ID);

        sim.treeSeqSimplify();
        sim.treeSeqOutput(paste(OUTTREES, "/", ID, ".trees", sep=""));

        sim.simulationFinished();
    }
}
