// ABCtrees_expansion.slim  (tree-seq + deleterious-forward-only + instantaneous expansion)
//
// Required -d parameters:
//   ID, gmu, imu, gd, id, gdfe, idfe
//
// Optional -d parameters (match ABCtrees.slim):
//   END (default 40000)
//   OUTTREES (default ".")
//   SIMPLIFY_INTERVAL (default 200)
//   NPOP (default computed from NE_REAL/Q; present-day size)
//   SELF (default 0.98)
//   Q (default 50)
//   NE_REAL (default 300000)
//   R_REAL (default 4e-8)
//   GENOMEINFO_DIR (default "genomeinfo")  // contains gene100.csv + intergene100.csv
//   GENEFILE (overrides GENOMEINFO_DIR)
//   INTERFILE (overrides GENOMEINFO_DIR)
//
// Demography -d parameters (optional):
//   T_EXP (default 30000)        : expansion generation (forward time; jump to NPOP)
//   EXP_MULT (default 3.0)       : NPOP = EXP_MULT * N_ANC  (so N_ANC = NPOP / EXP_MULT)
//
// Notes:
// - gdfe/idfe are BIOLOGICAL means (negative). We scale by Q to preserve Ne*s.
// - gmu/imu are BIOLOGICAL mutation rates. We scale by Q to preserve theta=4Nmu.
// - Recombination scaled by Q to preserve rho=4Nr.

initialize() {

    // ----------------------------
    // Defaults for optional params
    // ----------------------------
    if (!exists("Q"))      defineConstant("Q", 50.0);
    if (!exists("NE_REAL"))defineConstant("NE_REAL", 300000.0);
    if (!exists("R_REAL")) defineConstant("R_REAL", 4e-8);

    if (!exists("END")) defineConstant("END", 40000);
    if (!exists("OUTTREES")) defineConstant("OUTTREES", ".");
    if (!exists("SIMPLIFY_INTERVAL")) defineConstant("SIMPLIFY_INTERVAL", 200);
    if (!exists("SELF")) defineConstant("SELF", 0.98);

    // If NPOP not provided, compute from Ne_real / Q
    // Back-compat: if older pipeline passes N_END, accept it as NPOP.
    if (!exists("NPOP")) {
        if (exists("N_END"))
            defineConstant("NPOP", asInteger(N_END));
        else
            defineConstant("NPOP", asInteger(round(NE_REAL / Q)));
    }

    // Portable genomeinfo paths
    if (!exists("GENOMEINFO_DIR")) defineConstant("GENOMEINFO_DIR", "genomeinfo");

    if (!exists("GENEFILE"))
        defineConstant("GENEFILE", paste(GENOMEINFO_DIR, "/gene100.csv", sep=""));
    if (!exists("INTERFILE"))
        defineConstant("INTERFILE", paste(GENOMEINFO_DIR, "/intergene100.csv", sep=""));

    // ----------------------------
    // Demography defaults
    // ----------------------------
    if (!exists("T_EXP")) defineConstant("T_EXP", asInteger(round(END * 0.75)));
    if (!exists("EXP_MULT")) defineConstant("EXP_MULT", 3.0);

    // Guards
    if (T_EXP < 1) stop("T_EXP must be >= 1.");
    if (T_EXP > END) stop("Require T_EXP <= END (expansion must occur before output).");
    if (EXP_MULT < 1.0) stop("EXP_MULT must be >= 1.0.");

    // ----------------------------
    // Read genomic intervals
    // ----------------------------
    genes = readFile(GENEFILE);
    gene_starts = NULL;
    gene_stops  = NULL;

    for (line in genes) {
        components = strsplit(line, ",");
        if (size(components) < 2) next;

        start = asInteger(components[0]);
        stop  = asInteger(components[1]);

        if (isNULL(start) | isNULL(stop)) next;

        gene_starts = c(gene_starts, start);
        gene_stops  = c(gene_stops,  stop);
    }

    intergenes = readFile(INTERFILE);
    inter_starts = NULL;
    inter_stops  = NULL;

    for (line in intergenes) {
        components = strsplit(line, ",");
        if (size(components) < 2) next;

        start = asInteger(components[0]);
        stop  = asInteger(components[1]);

        if (isNULL(start) | isNULL(stop)) next;

        inter_starts = c(inter_starts, start);
        inter_stops  = c(inter_stops,  stop);
    }

    defineConstant("L", max(gene_stops) + 1);

    // ----------------------------
    // Nucleotide-based model (must come before initializeTreeSeq)
    // ----------------------------
    initializeSLiMOptions(nucleotideBased=T);

    // Tree-sequence recording
    initializeTreeSeq();

    // Ancestral nucleotides
    initializeAncestralNucleotides(randomNucleotides(L));

    // ----------------------------
    // Mutation types (deleterious-only forward; scale selection by Q)
    // ----------------------------
    gdfe_sim = gdfe * Q;
    idfe_sim = idfe * Q;

    initializeMutationTypeNuc("m2", 0.1, "g", gdfe_sim, 0.270);  // gene deleterious
    initializeMutationTypeNuc("m3", 0.1, "g", idfe_sim, 0.270);  // intergene deleterious

    // Clamp gd/id into [0,1] for safety
    gd_eff = max(0.0, min(1.0, gd));
    id_eff = max(0.0, min(1.0, id));

    // Scale mutation rates for simulation (deleterious component only)
    gmu_del_sim = (gmu * gd_eff) * Q;
    imu_del_sim = (imu * id_eff) * Q;

    initializeGenomicElementType("g1", m2, 1.0, mmJukesCantor(gmu_del_sim));
    initializeGenomicElementType("g2", m3, 1.0, mmJukesCantor(imu_del_sim));

    initializeGenomicElement(g1, gene_starts, gene_stops);
    initializeGenomicElement(g2, inter_starts, inter_stops);

    // Scale recombination rate for simulation
    initializeRecombinationRate(R_REAL * Q);

    // Compute ancestral size from NPOP and EXP_MULT
    ancN = asInteger(round(NPOP / EXP_MULT));
    if (ancN < 2) ancN = 2;
    defineConstant("N_ANC", ancN);
}

// ----------------------------
// Truncation guardrail: prevent impossible s < -1
// ----------------------------
mutation(m2) {
    if (mut.selectionCoeff < -1.0)
        mut.setSelectionCoeff(-1.0);
    return T;
}

mutation(m3) {
    if (mut.selectionCoeff < -1.0)
        mut.setSelectionCoeff(-1.0);
    return T;
}

// Start in ancestral size (smaller), expand to NPOP at T_EXP
1 late() {
    sim.addSubpop("p1", N_ANC);
    p1.setSelfingRate(SELF);
}

// Main loop + simplify + expansion + output at END
1:40000 late() {

    gen = community.tick;

    // Expansion event
    if (gen == T_EXP) {
        p1.setSubpopulationSize(NPOP);
    }

    // Periodic tree-seq simplification
    if (SIMPLIFY_INTERVAL > 0) {
        if (gen % SIMPLIFY_INTERVAL == 0)
            sim.treeSeqSimplify();
    }

    // Stop and output at END
    if (gen == END) {
        catn("Simulation reached generation " + END + " for ID " + ID);

        sim.treeSeqSimplify();
        sim.treeSeqOutput(paste(OUTTREES, "/", ID, ".trees", sep=""));

        sim.simulationFinished();
    }
}
